#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üîç DIAGN√ìSTICO COMPLETO - ICT ENGINE v6.0 ENTERPRISE
===================================================

Diagn√≥stico detallado de problemas actuales del sistema:
- Sistema de logging central
- Estado SIC v3.1 Enterprise  
- Problemas de imports
- Estructura de archivos
- Configuraciones

Autor: ICT Engine v6.0 Team
"""

import sys
import traceback
import logging
from pathlib import Path
import json

# Setup paths
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

def diagnosticar_logging():
    """üîç Diagnosticar sistema de logging central"""
    print("üîç DIAGN√ìSTICO SISTEMA DE LOGGING")
    print("-" * 50)
    
    problemas = []
    
    try:
        # Verificar configuraci√≥n de logging
        print("1Ô∏è‚É£ Verificando configuraci√≥n de logging...")
        
        # Verificar logger root
        root_logger = logging.getLogger()
        print(f"   üìä Root logger level: {root_logger.level}")
        print(f"   üìä Handlers: {len(root_logger.handlers)}")
        
        # Verificar directorio de logs
        logs_dir = project_root / "logs"
        if logs_dir.exists():
            log_files = list(logs_dir.glob("*.log"))
            print(f"   üìÅ Directorio logs: ‚úÖ {len(log_files)} archivos")
        else:
            print("   üìÅ Directorio logs: ‚ùå NO EXISTE")
            problemas.append("Directorio logs no existe")
        
        # Verificar smart_trading_logger
        try:
            from core.smart_trading_logger import SmartTradingLogger
            logger = SmartTradingLogger()
            print("   üîß SmartTradingLogger: ‚úÖ DISPONIBLE")
        except Exception as e:
            print(f"   üîß SmartTradingLogger: ‚ùå ERROR - {e}")
            problemas.append(f"SmartTradingLogger error: {e}")
            
    except Exception as e:
        print(f"   ‚ùå ERROR GENERAL: {e}")
        problemas.append(f"Error general logging: {e}")
    
    return problemas

def diagnosticar_sic():
    """üîç Diagnosticar SIC v3.1 Enterprise"""
    print("\nüîç DIAGN√ìSTICO SIC v3.1 ENTERPRISE")
    print("-" * 50)
    
    problemas = []
    
    try:
        print("1Ô∏è‚É£ Verificando estructura SIC...")
        
        # Verificar directorio sistema
        sistema_dir = project_root / "sistema"
        if sistema_dir.exists():
            print(f"   üìÅ Directorio sistema: ‚úÖ EXISTE")
            
            # Verificar SIC v3.1
            sic_dir = sistema_dir / "sic_v3_1"
            if sic_dir.exists():
                print(f"   üìÅ SIC v3.1: ‚úÖ EXISTE")
                
                # Verificar archivos clave
                archivos_clave = [
                    "__init__.py",
                    "enterprise_interface.py",
                    "lazy_loading.py", 
                    "predictive_cache.py",
                    "monitor_dashboard.py",
                    "advanced_debug.py"
                ]
                
                for archivo in archivos_clave:
                    archivo_path = sic_dir / archivo
                    if archivo_path.exists():
                        print(f"   üìÑ {archivo}: ‚úÖ")
                    else:
                        print(f"   üìÑ {archivo}: ‚ùå FALTA")
                        problemas.append(f"Archivo SIC faltante: {archivo}")
            else:
                print("   üìÅ SIC v3.1: ‚ùå NO EXISTE")
                problemas.append("Directorio SIC v3.1 no existe")
        else:
            print("   üìÅ Directorio sistema: ‚ùå NO EXISTE") 
            problemas.append("Directorio sistema no existe")
        
        print("\n2Ô∏è‚É£ Probando imports SIC...")
        
        # Test import b√°sico
        try:
            from sistema import get_sic_instance, smart_import
            print("   üì¶ Import b√°sico: ‚úÖ FUNCIONA")
            
            # Test instancia SIC
            sic = get_sic_instance()
            print(f"   üèóÔ∏è Instancia SIC: ‚úÖ {type(sic)}")
            
            # Test smart import
            sys_module = smart_import('sys')
            print(f"   üß† Smart import: ‚úÖ {type(sys_module)}")
            
        except Exception as e:
            print(f"   üì¶ Import SIC: ‚ùå ERROR - {e}")
            problemas.append(f"Error import SIC: {e}")
    
    except Exception as e:
        print(f"   ‚ùå ERROR GENERAL SIC: {e}")
        problemas.append(f"Error general SIC: {e}")
    
    return problemas

def diagnosticar_imports():
    """üîç Diagnosticar problemas de imports"""
    print("\nüîç DIAGN√ìSTICO PROBLEMAS DE IMPORTS")
    print("-" * 50)
    
    problemas = []
    
    # Tests de imports cr√≠ticos
    imports_criticos = [
        ("core.data_management.advanced_candle_downloader", "AdvancedCandleDownloader"),
        ("core.analysis.market_structure_analyzer", "MarketStructureAnalyzer"),
        ("core.analysis.pattern_detector", "PatternDetector"),
        ("core.poi_system", "POISystem"),
        ("utils.mt5_data_manager", "MT5DataManager")
    ]
    
    for modulo, clase in imports_criticos:
        try:
            module = __import__(modulo, fromlist=[clase])
            cls = getattr(module, clase)
            print(f"   üì¶ {modulo}.{clase}: ‚úÖ")
        except ImportError as e:
            print(f"   üì¶ {modulo}.{clase}: ‚ùå IMPORT ERROR - {e}")
            problemas.append(f"Import error: {modulo}.{clase}")
        except AttributeError as e:
            print(f"   üì¶ {modulo}.{clase}: ‚ùå ATTR ERROR - {e}")
            problemas.append(f"Attribute error: {modulo}.{clase}")
        except Exception as e:
            print(f"   üì¶ {modulo}.{clase}: ‚ùå ERROR - {e}")
            problemas.append(f"Error general: {modulo}.{clase}")
    
    return problemas

def diagnosticar_estructura():
    """üîç Diagnosticar estructura de archivos"""
    print("\nüîç DIAGN√ìSTICO ESTRUCTURA DE ARCHIVOS")
    print("-" * 50)
    
    problemas = []
    
    # Directorios esenciales
    directorios_esenciales = {
        "core": "N√∫cleo del sistema",
        "core/data_management": "Gesti√≥n de datos",
        "core/analysis": "An√°lisis ICT",
        "tests": "Tests del sistema",
        "scripts": "Scripts ejecutables",
        "utils": "Utilidades",
        "config": "Configuraciones",
        "logs": "Logs del sistema",
        "data": "Datos del sistema",
        "sistema": "SIC v3.1"
    }
    
    for directorio, descripcion in directorios_esenciales.items():
        dir_path = project_root / directorio
        if dir_path.exists():
            archivos_py = len(list(dir_path.glob("*.py")))
            print(f"   üìÅ {directorio}/: ‚úÖ {archivos_py} archivos Python")
        else:
            print(f"   üìÅ {directorio}/: ‚ùå NO EXISTE")
            problemas.append(f"Directorio faltante: {directorio}")
    
    return problemas

def diagnosticar_configuraciones():
    """üîç Diagnosticar configuraciones"""
    print("\nüîç DIAGN√ìSTICO CONFIGURACIONES")
    print("-" * 50)
    
    problemas = []
    
    # Archivos de configuraci√≥n esperados
    configs_esperadas = [
        "config/performance_config_enterprise.json",
        "config/storage_config.json",
        "config/cache_config.json",
        "config/sic_cache_stats.json"
    ]
    
    for config_file in configs_esperadas:
        config_path = project_root / config_file
        if config_path.exists():
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                print(f"   ‚öôÔ∏è {config_file}: ‚úÖ {len(data)} keys")
            except Exception as e:
                print(f"   ‚öôÔ∏è {config_file}: ‚ö†Ô∏è ERROR LECTURA - {e}")
                problemas.append(f"Config corrupta: {config_file}")
        else:
            print(f"   ‚öôÔ∏è {config_file}: ‚ùå NO EXISTE")
            # No es cr√≠tico, se puede generar autom√°ticamente
    
    return problemas

def generar_plan_reparacion(todos_problemas):
    """üîß Generar plan de reparaci√≥n"""
    print("\n" + "="*70)
    print("üîß PLAN DE REPARACI√ìN AUTOMATIZADA")
    print("="*70)
    
    if not todos_problemas:
        print("‚úÖ NO SE ENCONTRARON PROBLEMAS CR√çTICOS")
        return
    
    # Categorizar problemas
    problemas_criticos = []
    problemas_menores = []
    
    for problema in todos_problemas:
        if any(keyword in problema.lower() for keyword in ['import error', 'no existe', 'faltante']):
            problemas_criticos.append(problema)
        else:
            problemas_menores.append(problema)
    
    if problemas_criticos:
        print("üö® PROBLEMAS CR√çTICOS (REQUIEREN REPARACI√ìN):")
        for i, problema in enumerate(problemas_criticos, 1):
            print(f"   {i}. {problema}")
    
    if problemas_menores:
        print("\n‚ö†Ô∏è PROBLEMAS MENORES (NO CR√çTICOS):")
        for i, problema in enumerate(problemas_menores, 1):
            print(f"   {i}. {problema}")
    
    print(f"\nüìä RESUMEN: {len(problemas_criticos)} cr√≠ticos, {len(problemas_menores)} menores")

def main():
    """üéØ Diagn√≥stico principal"""
    print("üîç ICT ENGINE v6.0 ENTERPRISE - DIAGN√ìSTICO COMPLETO")
    print("="*70)
    
    todos_problemas = []
    
    # Ejecutar todos los diagn√≥sticos
    todos_problemas.extend(diagnosticar_logging())
    todos_problemas.extend(diagnosticar_sic())
    todos_problemas.extend(diagnosticar_imports())
    todos_problemas.extend(diagnosticar_estructura())
    todos_problemas.extend(diagnosticar_configuraciones())
    
    # Generar plan de reparaci√≥n
    generar_plan_reparacion(todos_problemas)
    
    # Test final del sistema cr√≠tico
    print("\nüß™ TEST SISTEMA CR√çTICO FINAL:")
    print("-" * 50)
    
    try:
        import subprocess
        result = subprocess.run(
            [sys.executable, "tests/test_simple_poi.py"],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if result.returncode == 0:
            print("‚úÖ SISTEMA CR√çTICO: FUNCIONANDO")
            print("üéØ A pesar de problemas menores, el n√∫cleo funciona")
        else:
            print("‚ùå SISTEMA CR√çTICO: FALLO")
            todos_problemas.append("Sistema cr√≠tico no funciona")
    except Exception as e:
        print(f"‚ùå ERROR TEST CR√çTICO: {e}")
        todos_problemas.append(f"Error test cr√≠tico: {e}")
    
    print(f"\n{'='*70}")
    if len([p for p in todos_problemas if 'import error' in p.lower() or 'no existe' in p.lower()]) == 0:
        print("üéâ SISTEMA EN BUEN ESTADO GENERAL")
        print("‚úÖ Problemas menores no afectan funcionalidad cr√≠tica")
    else:
        print("‚ö†Ô∏è SISTEMA REQUIERE REPARACI√ìN")
        print("üîß Ejecutar reparaciones sugeridas")
    
    return len(todos_problemas)

if __name__ == "__main__":
    num_problemas = main()
    sys.exit(1 if num_problemas > 5 else 0)
